% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/umf_solve_nl.R
\name{umf_solve_nl}
\alias{umf_solve_nl}
\title{Solves a system of non-linear equations using UMFPACK}
\usage{
umf_solve_nl(start, fn, jac, ..., control, global = c("no", "cline"),
  scaling = c("row", "col", "none"), umf_control = list())
}
\arguments{
\item{start}{initial guess of the solution \eqn{x}}

\item{fn}{the function \eqn{F}}

\item{jac}{a function returning the Jacobian of the function
as a \code{dgCMatrix} object}

\item{...}{arguments passed to \code{fn} and \code{jac}}

\item{control}{a list with control parameters. See Details.}

\item{global}{The global strategy. Possible values are \code{"no"}
(no global strategy, the default) and \code{"cline"} (cubic line search)
(cubic line search)}

\item{scaling}{Scaling method. Possible values are
\code{"row"}. \code{"col"} and \code{"none"}. The default is \code{"row"}.
See Details.}

\item{umf_control}{A named list with control parameters passed to UMFPACK.
For example, to use METIS column ordering use
\code{umf_control = list(ORDERING = "METIS")}. Using METIS column ordering may require
less memory than ordering ordering options, which may be useful for
very large matrices.
See for more information \code{\link{umf_control}}.}
}
\value{
a list with the following components:
\item{\code{solved}}{A logical equal to \code{TRUE} if convergence
of the function values has been achieved.}
\item{\code{iter}}{the number of iterations}
\item{\code{x}}{the final values of \eqn{x}}
\item{\code{fval}}{the function value }
\item{\code{message}}{A string equal to \code{"ok"} if a solution
has been found. Otherwise it describes the reason why the iteration
was stopped without success}
}
\description{
This function solves a system of non-linear equations  \eqn{F(x) = 0}
using Newton's method. UMFPACK is employed to solve the linear equations
in each Newton iteration. Optionally a cubic line search is used
when a Newton step does not yield a sufficient reduction of the function values.
}
\details{
\subsection{Control options}{
Argument \code{control} is a named list containing one or more of
the following components:
\describe{
\item{\code{ftol}}{The function value tolerance. Convergence is reached
if the largest function value is smaller than \code{ftol}. The default
value is \code{1e-8}.}
\item{\code{xtol}}{The relative step size tolerance. When the relative
step size is smaller than \code{xtol}, then the iteration is stopped.
The default value is \code{1e-8}.}
\item{\code{maxiter}}{The maximum number of iterations. The default is 20.}
\item{\code{trace}}{A logical. If \code{TRUE}  then the progress of the
iteraton is printed. The default is \code{FALSE}.}
\item{\code{silent}}{A logical. If \code{TRUE}  then all output is suppressed.
The default is \code{FALSE}.}
\item{\code{allow_singular}}{A logical value (default \code{FALSE})
indicating if a small correction to the Jacobian is applied when it is
singular or too ill-conditioned.
The method used is similar to a Levenberg-Marquardt correction
and is explained in Dennis and Schnabel (1996) on page 151.
}
\item{\code{allow_singular}}{A logical value (default \code{FALSE})
indicating if a small correction to the Jacobian is applied when it is
singular. The method used is similar to a Levenberg-Marquardt correction
and is explained in Dennis and Schnabel (1996) on page 151.
}}}
\subsection{Scaling of the Jacobian}{
For each iteration in the Newton method the linear system \eqn{J s = F(x)} is
solved, where the Jacobiab matrix \eqn{J} are the derivatives of the equations
with respect to the variables, and \eqn{s} the Newton step.  Scaling
can improve the condition of the Jacobian.
For \emph{row scaling}, the system is transformed to
\eqn{D^{-1} J s = D^{-1} F(x)}, where \eqn{D} is a diagonal matrix with
row scaling factors. Here  the scaling factors are the L1 norms of the rows
of \eqn{J}. For \emph{column scaling}, the system is transformed to
\eqn{J D^{-1} D s = F(x)}, where \eqn{D} is a diagonal matrix with column
scaling factors, calculated from  the L1 norms of the columns of \eqn{J}.

The scaling is only used to solve the non-linear equations and has no effect
on the convergence of the Newton algorihtm. Thus the iterations
are considered to be converged when the maximum value of the unscaled
function values \eqn{F(x)} is smaller than \code{ftol}.
}
}
\examples{
library(umfpackr)

dslnex <- function(x, c) {
   y <- numeric(2)
   y[1] <- x[1]^2 + x[2]^2 - c
   y[2] <- exp(x[1]-1) + x[2]^3 - c
   y
}

jacdsln <- function(x, c) {
   n <- length(x)
   Df <- matrix(numeric(n*n),n,n)
   Df[1,1] <- 2*x[1]
   Df[1,2] <- 2*x[2]
   Df[2,1] <- exp(x[1]-1)
   Df[2,2] <- 3*x[2]^2

   return(as(Df, "dgCMatrix"))
}


xstart <- c(2,3)
print(umf_solve_nl(xstart, dslnex, jacdsln, c = 2,
                  control = list(trace = TRUE)))

# now use METIs columns ordering (run this on Linux only)
if (.Platform$OS.type != "windows") {
   print(umf_solve_nl(xstart, dslnex, jacdsln, c = 2,
                  control = list(trace = TRUE),
                  umf_control = list(SCALE = NONE,
                                     ORDERING = "METIS")))
}
}
\references{
Dennis, J.E. Jr and Schnabel, R.B. (1997), \emph{Numerical Methods for
Unconstrained Optimization and Nonlinear Equations}, Siam.

Davis, T.A. (2004). A column pre-ordering strategy for the unsymmetric-pattern
multifrontal method. \emph{ACM Trans. Math. Softw.}, \bold{30(2)}, 165–195.

Davis, T.A (2004). Algorithm 832: UMFPACK, an unsymmetric-pattern multifrontal
method. \emph{ACM Trans. Math. Softw.}, \bold{30(2)}, 196–199.

Davis, T.A and Duff, I.S. (1997). An unsymmetric-pattern multifrontal method for
sparse LU factorization. \emph{SIAM J. Matrix Anal. Applic.}, \bold{18(1)}, 140–158.

Davis, T.A  and Duff, I.S (1999). A combined unifrontal/multifrontal method for
unsymmetric sparse matrices. \emph{ACM Trans. Math. Softw.}, \bold{25(1)}, 1–19..
}
\seealso{
\code{\link{umf_solve}}
}
