% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/umf_solve_nl.R
\name{umf_solve_nl}
\alias{umf_solve_nl}
\title{Solves a system of non-linear equations using UMFPACK}
\usage{
umf_solve_nl(start, fn, jac, ..., control, global = c("no", "cline"),
  scaling = c("row", "col", "none"), umf_control = list())
}
\arguments{
\item{start}{initial guess of the solution \eqn{x}}

\item{fn}{the function \eqn{F}}

\item{jac}{a function returning the Jacobian of the function
as a \code{dgCMatrix} object}

\item{...}{arguments passed to \code{fn} and \code{jac}}

\item{control}{a list with control parameters. See Details.}

\item{global}{The global strategy. Possible values are \code{"no"}
(no global strategy, the default) and \code{"cline"} (cubic line search)
(cubic line search)}

\item{scaling}{Scaling method. Possible values are
\code{"row"}. \code{"col"} and \code{"none"}. The default is \code{"row"}.
See Details.}

\item{umf_control}{A named list with control parameters passed to UMFPACK.
Currently only a single control parameter can specified: \code{ordering}, which
specifies the ordering method. Allowed values are \code{"AMD"} (the default),
\code{"CHOLMOD"}, \code{"METIS"} and \code{"BEST"}. See the Vignette
\href{../doc/UMFPACK_interface.pdf}{\emph{UMFPACK interface for R}} for more
details. For example, to use METIS ordering specify
\code{umf_control = list(ORDERING = "METIS")}. The METIS ordering method can
handle larger matrices than the standard AMD method.}
}
\value{
a list with the following components:
\item{\code{solved}}{A logical equal to \code{TRUE} if convergence
of the function values has been achieved.}
\item{\code{iter}}{the number of iterations}
\item{\code{x}}{the final values of \eqn{x}}
\item{\code{fval}}{the function value }
\item{\code{message}}{A string equal to \code{"ok"} if a solution
has been found. Otherwise it describes the reason why the iteration
was stopped without success}
}
\description{
This function solves a system of non-linear equations  \eqn{F(x) = 0}
using Newton's method. UMFPACK is employed to solve the linear equations
in each Newton iteration. Optionally a cubic line search is used
when a Newton step does not yield a sufficient reduction of the function values.
}
\details{
\subsection{Control options}{
Argument \code{control} is a named list containing one or more of
the following components:
\describe{
\item{\code{ftol}}{The function value tolerance. Convergence is reached
if the largest function value is smaller than \code{ftol}. The default
value is \code{1e-8}.}
\item{\code{xtol}}{The relative step size tolerance. When the relative
step size is smaller than \code{xtol}, then the iteration is stopped.
The default value is \code{1e-8}.}
\item{\code{maxiter}}{The maximum number of iterations. The default is 20
if no global strategy is used (argument \code{global = "no"}), and 150
if cublic line searching is used (argument \code{global = "cline"}).}
\item{\code{trace}}{A logical. If \code{TRUE}  then the progress of the
iteraton is printed. The default is \code{FALSE}.}
\item{\code{silent}}{A logical. If \code{TRUE}  then all output is suppressed.
The default is \code{FALSE}.}
\item{\code{cnd_tol}}{The tolerance for the inverse condition of the jacobian.
If the inverse condition is smaller than \code{cnd_tol}, the solution process
is terminated with an error, except if control parameter \code{allow_singular} is
set to \code{TRUE}. The default is the machine precision (on most platforms
about \code{2e-16}). If the inverse condition is very small but nonzero
it may be difficult to find a solution, or the solution may not be
meaningful. However, sometimes a good solution can be found even if the
condition is quite small. The test  for the ill-conditioning of the
jacobian can be turned off by setting \code{cndtol} to 0 or a negative number.
However, if the matrix is singular (the inverse condition is exactly zero),
it is not possible to continue with the solution process
(except if control parameter \code{allow_singular} is set to \code{TRUE}).
The default value of \code{cnd_tol} is quite small, in some cases it can be
appropiate to use a somewhat larger value (\code{1e-12})}
\item{\code{cnd_method}}{A character vector specifying the method used to
estimate the inverse condition number of the jacobian. Possible options are
\code{"umfpack"}(the default), \code{"condest"} and \code{"kappa"}.
For \code{"umfpack"} a rough estimate of the condition as computed by UMFPACK is
used, using the expression \code{min(abs(diag(U)))/max(abs(diag(U)))},
where \code{U} is the \code{U} matrix of the LU factorization of the jacobian.
\code{"condest"} employs function \code{\link[Matrix]{condest}} of the \code{Matrix}
package and \code{kappa} the function \code{\link[base]{kappa}} of the \code{base} package.
Method \code{condtest} is more accurate than the rough estimate of UMFPACK,
but takes more time. \code{kappa} is essentially exact, but is very slow for large
matrices because this function does not use sparse matrices.
Method \code{"condest"} usually gives a reasonable approximation of the
inverse condition number.
It is recommended to normally use \code{"umfpack"}, but occasionally use \code{"condest"}
for a more accurate check of the condition number.}
\item{\code{allow_singular}}{A logical value (default \code{FALSE})
indicating if a small correction to the Jacobian is applied when it is
singular or too ill-conditioned.
The method used is similar to a Levenberg-Marquardt correction
and is explained in Dennis and Schnabel (1996) on page 151.
If \code{TRUE}, then the correction is applied if the inverse condition is
exactly zero or if the inverse condition is smaller than control
parameter \code{cndtol}.
}
}}
\subsection{Scaling of the Jacobian}{
For each iteration in the Newton method the linear system \eqn{J s = F(x)} is
solved, where the Jacobiab matrix \eqn{J} are the derivatives of the equations
with respect to the variables, and \eqn{s} the Newton step.  Scaling
can improve the condition of the Jacobian.
For \emph{row scaling}, the system is transformed to
\eqn{D^{-1} J s = D^{-1} F(x)}, where \eqn{D} is a diagonal matrix with
row scaling factors. Here  the scaling factors are the L1 norms of the rows
of \eqn{J}. For \emph{column scaling}, the system is transformed to
\eqn{J D^{-1} D s = F(x)}, where \eqn{D} is a diagonal matrix with column
scaling factors, calculated from  the L1 norms of the columns of \eqn{J}.

The scaling is only used to solve the non-linear equations and has no effect
on the convergence of the Newton algorihtm. Thus the iterations
are considered to be converged when the maximum value of the unscaled
function values \eqn{F(x)} is smaller than \code{ftol}.
}
}
\examples{
library(umfpackr)

dslnex <- function(x, c) {
   y <- numeric(2)
   y[1] <- x[1]^2 + x[2]^2 - c
   y[2] <- exp(x[1]-1) + x[2]^3 - c
   y
}

jacdsln <- function(x, c) {
   n <- length(x)
   Df <- matrix(numeric(n*n),n,n)
   Df[1,1] <- 2*x[1]
   Df[1,2] <- 2*x[2]
   Df[2,1] <- exp(x[1]-1)
   Df[2,2] <- 3*x[2]^2

   return(as(Df, "dgCMatrix"))
}


xstart <- c(2,3)
print(umf_solve_nl(xstart, dslnex, jacdsln, c = 2,
                  control = list(trace = TRUE)))

# now use METIs columns ordering (run this on Linux only)
if (.Platform$OS.type != "windows") {
   print(umf_solve_nl(xstart, dslnex, jacdsln, c = 2,
                  control = list(trace = TRUE),
                  umf_control = list(ordering = "METIS")))
}
}
\references{
Dennis, J.E. Jr and Schnabel, R.B. (1997), \emph{Numerical Methods for
Unconstrained Optimization and Nonlinear Equations}, Siam.

Davis, T.A. (2004). A column pre-ordering strategy for the unsymmetric-pattern
multifrontal method. \emph{ACM Trans. Math. Softw.}, \bold{30(2)}, 165–195.

Davis, T.A (2004). Algorithm 832: UMFPACK, an unsymmetric-pattern multifrontal
method. \emph{ACM Trans. Math. Softw.}, \bold{30(2)}, 196–199.

Davis, T.A and Duff, I.S. (1997). An unsymmetric-pattern multifrontal method for
sparse LU factorization. \emph{SIAM J. Matrix Anal. Applic.}, \bold{18(1)}, 140–158.

Davis, T.A  and Duff, I.S (1999). A combined unifrontal/multifrontal method for
unsymmetric sparse matrices. \emph{ACM Trans. Math. Softw.}, \bold{25(1)}, 1–19..
}
\seealso{
\code{\link{umf_solve}}.
}
